### **1. 快照序列化与压缩 (Snapshot Serialization & Compression)​**​

| ​**​技术点​**​                   | ​**​Unity NetCode (DOTS)​**​                                                            | ​**​传统框架 (如 Photon, Mirror)​**​                                                       | ​**​GGPO (Rollback Netcode)​**​                                  |
| ----------------------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| ​**​序列化单元​**​                 | ​**​字段级 (Field-Level)​**​  <br>- 基于 `[GhostField]`属性标记组件字段  <br>- 自动生成针对 ECS 内存布局的序列化代码 | ​**​对象级 (Object-Level)​**​  <br>- 需手动实现 `ISerializable`或标记 `[SyncVar]`  <br>- 整个对象序列化 | ​**​自定义结构体 (Custom Structs)​**​  <br>- 开发者定义包含状态的 `GameState`结构体 |
| ​**​变化检测​**​                  | ​**​原型级脏数据系统​**​  <br>- 利用 ECS 的 `ArchetypeChunk`检测同原型实体字段变化  <br>- 生成字段级变化掩码           | ​**​对象级脏标记​**​  <br>- 每个网络对象独立标记是否变化  <br>- 粗粒度（整个对象变化）                               | ​**​整状态对比​**​  <br>- 每帧完整计算 `GameState`哈希或逐字段比较  <br>- 无细粒度脏标记   |
| ​**​增量压缩 (Delta Compress)​**​ | ​**​多基线 + 字段级增量​**​  <br>- 对每个字段独立选择最优基线  <br>- 支持 `Composite`字段组原子压缩                   | ​**​单基线 + 对象级增量​**​  <br>- 通常只对比上一帧状态  <br>- 整对象序列化差异                                 | ​**​无增量压缩​**​  <br>- 依赖状态哈希校验  <br>- 全量状态传输（或自定义差异算法）            |
| ​**​量化 (Quantization)​**​     | ​**​字段级精度控制​**​  <br>- 每个 `[GhostField]`独立设置量化参数  <br>- 支持非线性量化（如角度）                    | ​**​手动实现​**​  <br>- 需在序列化代码中硬编码精度转换                                                   | ​**​内置量化支持弱​**​  <br>- 通常由开发者预处理状态值                              |

​**​关键差异：​**​

Unity 利用 ECS 的​**​内存连续性​**​和​**​原型结构​**​，实现​**​字段级细粒度序列化​**​，而传统框架基于对象粒度。GGPO 更关注状态一致性，压缩非核心目标。


### ​**​2. 回滚机制 (Rollback Mechanism)​**​

| ​**​技术点​**​    | ​**​Unity NetCode (DOTS)​**​                                                      | ​**​传统框架​**​                                                         | ​**​GGPO​**​                                          |
| -------------- | --------------------------------------------------------------------------------- | -------------------------------------------------------------------- | ----------------------------------------------------- |
| ​**​回滚粒度​**​   | ​**​实体组件级 (Component-Level)​**​  <br>- 仅回滚 `Predicted`组件的状态  <br>- 非预测组件（如渲染）不受影响 | ​**​对象级 (Object-Level)​**​  <br>- 回滚整个 GameObject 状态  <br>- 可能影响无关组件 | ​**​整状态快照 (Full State)​**​  <br>- 回滚整个 `GameState`结构体 |
| ​**​状态备份​**​   | ​**​按原型分块存储​**​  <br>- 基于 `Archetype`存储组件备份  <br>- `EntityCommandBuffer`内置回滚缓存    | ​**​对象状态克隆​**​  <br>- 深拷贝网络对象或序列化备份                                  | ​**​状态栈 (State Stack)​**​  <br>- 保存历史 `GameState`快照   |
| ​**​重放执行​**​   | ​**​JobSystem 并行重放​**​  <br>- 将回放任务拆分为并行 Job  <br>- Burst 编译加速逻辑执行                | ​**​主线程顺序重放​**​  <br>- 单线程遍历对象执行 `Simulate`                          | ​**​确定性锁步重放​**​  <br>- 单线程按帧顺序执行输入                    |
| ​**​回滚范围控制​**​ | ​**​`ShouldPredict`动态过滤​**​  <br>- 基于 `AppliedTick`跳过已确认实体  <br>- 仅回滚未确认实体        | ​**​全场景回滚​**​  <br>- 无差别回滚所有网络对象                                     | ​**​固定帧窗口回滚​**​  <br>- 回滚到最近确认帧                       |

​**​关键差异：​**​

Unity 的​**​组件级回滚​**​和​**​ECS 原生备份机制​**​最小化内存操作，而传统框架需深拷贝对象。GGPO 的整状态回滚简单但内存开销大。

---

### ​**​3. 输入处理与预测 (Input Handling & Prediction)​**​

|​**​技术点​**​|​**​Unity NetCode (DOTS)​**​|​**​传统框架​**​|​**​GGPO​**​|
|---|---|---|---|
|​**​输入存储​**​|​**​`CommandBuffer`按 Tick 存储​**​  <br>- 每个 `NetworkTick`对应独立 `ICommandData`  <br>- 基于 `Entity`关联输入|​**​输入事件队列​**​  <br>- 按帧存储未处理输入事件  <br>- 与对象弱关联|​**​环形输入缓冲区​**​  <br>- 固定大小数组存储每帧输入  <br>- 索引对应帧号|
|​**​输入应用​**​|​**​`CommandTarget`组件绑定​**​  <br>- 实体通过 `CommandTarget`关联输入  <br>- 预测时自动注入对应 Tick 输入|​**​手动分发输入​**​  <br>- 需在对象脚本中实现 `OnInput()`回调|​**​全局输入处理​**​  <br>- 在 `GameState`更新中应用当前帧输入|
|​**​预测范围限制​**​|​**​`MaxPredictionStep`硬限制​**​  <br>- 强制停止超限实体的预测  <br>- 防止无限领先|​**​无内置保护​**​  <br>- 依赖开发者手动控制|​**​固定回滚窗口​**​  <br>- 通过窗口大小隐式限制预测|

​**​关键差异：​**​

Unity 的​**​Tick 对齐输入缓冲区​**​和​**​实体-输入绑定机制​**​，与 ECS 调度深度集成，而传统框架依赖事件回调。

---

### ​**​4. 实体预测范围控制 (Prediction Scope)​**​

|​**​技术点​**​|​**​Unity NetCode (DOTS)​**​|​**​传统框架​**​|​**​GGPO​**​|
|---|---|---|---|
|​**​预测开关​**​|​**​`Predicted`标签组件​**​  <br>- 实体添加 `Predicted`组件才参与预测  <br>- 与 `Interpolated`互斥|​**​基于 NetworkIdentity​**​  <br>- 所有网络对象默认参与预测|​**​全状态预测​**​  <br>- 无实体级开关，整局预测|
|​**​预测粒度控制​**​|​**​`GhostPredictionSystem`按实体过滤​**​  <br>- 基于 `ShouldPredict()`逐实体判断是否需预测|​**​组件回调控制​**​  <br>- 在 `NetworkBehaviour`中覆写预测逻辑|​**​无细粒度控制​**​  <br>- 所有实体强制预测|
|​**​外推策略 (Extrapolation)​**​|​**​`SmoothingAction.InterpolateAndExtrapolate`​**​  <br>- 基于速度/角速度线性外推  <br>- `MaxSmoothingDistance`限制|​**​无内置外推​**​  <br>- 需手动实现|​**​无外推​**​  <br>- 依赖快照插值|

​**​关键差异：​**​

Unity 的​**​实体级预测开关​**​和​**​物理驱动的外推​**​是独特设计，传统框架通常全有或全无，GGPO 不处理外推。

---

### ​**​总结：Unity NetCode 的核心创新点​**​

1. ​**​ECS 原生集成架构​**​
    
    - 利用 `Archetype`/`Chunk`实现字段级序列化与脏检测
        
    - 组件级回滚（非对象级）
        
    - JobSystem 并行化重放
        
    
2. ​**​预测与渲染分离​**​
    
    - `Predicted`/`Interpolated`Ghost 双实体模式
        
    - 物理与逻辑状态解耦
        
    
3. ​**​工具链深度支持​**​
    
    - `GhostAuthoring`编辑器可视化配置
        
    - 自动生成序列化代码（基于 Roslyn）
        
    - NetCode Profiler 专项性能分析
        
    
4. ​**​DOTS 优化算法​**​
    
    - 多基线选择算法（0-3 个基线）
        
    - 基于原型的增量压缩
        
    - Burst 编译预测逻辑
        
    

​**​结论：​**​

Unity NetCode 并非发明了预测回滚理论，但在 ​**​ECS 架构下的工程实现​**​有显著突破：

- ​**​细粒度控制​**​（字段级序列化/组件级回滚）
    
- ​**​并行化处理​**​（JobSystem 调度）
    
- ​**​内存效率​**​（基于原型的存储）
    
- ​**​工具链整合​**​（编辑器到运行时闭环）