### 一、`C#`语言/`Unity`集成高级特性

#### 1) 协程 `Coroutine`

- **是什么**：一种特殊类型的函数，允许我们在函数执行的过程中临时退出，并保留函数执行的当前状态，以便之后恢复执行。

- **作用**：

	- 可以在执行过程中暂停，并在下一帧或指定时间后继续执行。
	
	- 通过`IEnumerator`返回类型和`yield`语句实现，使用`yield return`语句来指定暂停的间隔。
	
	- 游戏中主要用于时间相关的操作（延迟、动画、渐变）；以及分帧处理（避免卡顿）

- **使用方法/应用（以`MapManager`为例）**

#### 2) `List` 列表 数据结构

- **是什么**：本质是可变长数组，可视为数组的替代，并封装了一些常用的方法

- **使用方法/应用（以`Timer`为例）**

- **原理**：内存的动态扩容，每次添加新元素都开辟一片新内存存储元素 

- **注意事项**：`Insert()`, `Contains()`, `Remove()`等操作，时间复杂度是O(n)，也就是每次操作都要遍历一遍列表，若列表元素量大，谨慎使用。

#### 3) `Dictionary` 字典/键值对 数据结构

- **作用**：存储一对键与值之间的映射关系，主要提供快速高效的查找能力。（比如`List`中查找元素是`O(n)`,`Dictionary`中通过键来找值就可以完成`O(1)`查找）

- **使用方法/应用（以`Timer`为例）

- **原理**：哈希表

- **注意事项**：

	- 不要在遍历字典时修改或增删元素，

	- 如有需要，在遍历中维护一个pair类型的List，遇到要修改或增删的就加入，字典遍历结束后，通过遍历List统一增删或修改。

#### 4) 委托与事件

##### 回调的概念与用途

- 在没有回调时，我们想要在特定时机实现一个功能，那么就要在代码的特定行调用一个实现该功能的函数

- 但是，在很多情况下，这个功能会依赖于我们程序的上下文，比如外部的变量，来判断自己是否需要执行。

- 一种方法，在外部暴露出一个变量，是在那个实现该功能的函数中传入一个锚定上下文的标识变量（如`bool`, `int`, 或枚举），并通过条件分支语句选择对应逻辑

- **但这种方式会带来三个问题**

	- **灵活性**：我们想要在那个时机下加入其他功能，就要去修改那个函数，这涉及到对已有业务逻辑的修改

	- **耦合性**：需读取外部变量或方法

	- **性能损耗**：很多情况下，对外部变量的读取需要通过不断更新的方式来查询，降低代码性能和优雅度

- 那么回调，即**传入一个函数变量**，来让程序在特定行调用，就能够解决以上问题：

	- 需要其他分支逻辑只需更改传入变量的值，不更改具体的已有业务逻辑

	- 无需读取外部变量或方法

	- 无需不断更新和查询

- **举个例子**：上早八的大学生

##### delegate - 委托 

- **是什么**：本质上是一个类，和封装好的函数指针，是用于装载刚刚提到的**函数变量**的容器

- 需采用类似类的声明和实例化的方式来声明或定义一个函数委托

- 可以在委托中存入多个函数

- 可以类比于一种约定，委托约定了其装载的函数的返回值和接收参数类型（否则无法统一调用），但具体的函数体可以随意指定，并通过`.Invoke()`或直接`()`调用（后者不推荐，是语法糖，语义不清晰）。

##### event - 事件

- **是什么**：本质上是一个委托的实例修饰符，是对委托的再封装。

- 这种特殊类型的委托，禁止了对委托的直接赋值操作，以及外界对委托的直接调用（即便这个委托是`public`的）

- 从语义上来看，其是对观察订阅-被观察者发布流程的适配。观察者只能够订阅或取消订阅，也就是将自己的方法存入事件或从事件中移除，等待其被发布者调用。

- 而外部无法替代发布者触发事件（即便事件是公共的，可以被访问的），或者对事件进行赋值（因为这可能会清除事件接收的来自其他观察者的订阅）。

##### Action - C#提供的封装好的委托定义

- **是什么**：本质上是一个`System`提供的委托定义，封装（或说定义）了一种无返回值的委托类型

- 相当于 `delegate void MyAction();`

- 但同时提供了多种泛型支持，例如`Action<T>`定义了有一个T类型参数的无返回值委托，相当于`delegate void MyAction<T>(T value);`

- `Action<T1, T2, T3>...`同样被支持，定义了任意数量（最多16个）T类型参数的无返回值委托

- 举个例子：`ReactiveProperty<T>`的`Action`使用

#### 5) `Lambda`表达式

- **是什么**：本质是匿名函数的语法糖，简化代码编写

- **使用方法/应用（以`Timer`为例）

- **原理**： => 前是传入的参数； => 后面的大括号包裹具体的函数体和逻辑

- **注意事项**：
	- 不要在三行及以上的复杂业务逻辑处使用`Lambda`表达式
	- 如有需要，封装成函数，赋予有意义的命名，便于维护

### 二、游戏开发常用设计模式

#### 1) 单例模式

- **作用**：
	
	- 实例化一个全局唯一，且全局可访问的管理器，处理全局唯一的游戏数据和方法
	
	- 比如成就管理系统，在输入系统中玩家步数到达一千步时调用`AchievementManager.Instance.InvokeOneThousandStepAchievement()`

- **使用方法/应用（音频系统示例）**

- **原理**：

- 关键在`static`修饰的自指`Instance`。`static`修饰的变量称为静态变量，其生命周期为整个程序的开始到结束。

- 先在`Awake()` 中`Instance != null && Instance != this`（说明已经存在一个单例且不是自身）时`Destroy()`，确保了单例的唯一性；若单例当前不存在，通过`Instance = this`的赋值，成功在类内部包裹了一个对类实例自己的引用，使得外界可以访问。

- **注意事项**：
	
	- 不要过渡滥用单例模式，当且仅当你需要的“管理器”是全局唯一时才使用
	
	- 四处散落的单例以及方法调用会增加耦合

#### 2) 观察者模式与事件中心

- **作用**：

	- 实现事件驱动架构，观察者和发布者互相解藕，无需知道互相的具体实现，同时使得一个发布源发布的事件能够被多个观察者同时消费，这在游戏开发中十分常用。
	
	- 比如枪战游戏中，输入系统发布玩家开枪事件；检测系统进行射线检测；背包系统消耗子弹；音频系统播放音效；特效系统播放视觉特效

- **使用方法/应用**

	- 需要四大件：事件中心、事件类型、发布者、订阅者

	- （关卡天结束-打开Ani选择页面-关闭后开始下一天的流程示例）

- **原理**：

	- 本质上是事件类型-事件的映射封装。订阅者只关心自己订阅的事件类型和事件触发时要调用的方法；发布者只关心事件类型（和可能的要顺带事件一起发送的数据），映射工作由事件中心完成，形成解藕。
	
	- **具体流程为**：
	
		- 订阅者在事件中心中（若映射不存在时）注册一个事件类型-事件的映射，存入要被调用的方法，等待时机到达时发布者发布(`Subscribe<T>(UnityAction action)`)；
		
		- 时机到达，发布者在发布时根据该映射调用事件中存储的所有函数，并传入事件类型中定义的数据(`event.Invoke(EventDataType data)` ; `)；（event -> EventDataType的映射）
	
		- 订阅者接收到数据，同时注册的函数被调用，依据接收数据执行逻辑`(MyAction(EventDataType data)`)。
		
		- 订阅者生命周期结束时，将方法从事件中移除(`Unsubscribe<T>(UnityAction action)`)

- **注意事项**：
	
	- 观察者订阅事件后，要在自己的生命周期结束时及时取消订阅，防止内存泄漏（观察者游戏对象被销毁，但其注册的方法还存在于事件中心或发布者中）
	
	- 教程中的观察者模式示例中，大部分订阅者都没有取消订阅，并且使用`lambda`表达式订阅事件很难取消订阅。可能因为大部分订阅者的生命周期都是整个游戏，或者与发布者的生命周期相同，不取消的话影响不大
	
	- 但为遵循现代软件工程的最佳实践，还是建议取消订阅

### 三、开发中注意事项

#### 1) 架构图设计

- 首先先明晰自己的游戏有哪些模块

- 开发具体模块时，先在架构图中将该模块的职能和实现逻辑写清楚，再去开发

- 最后写报告时有话可写，并且对自己的项目有一个更清晰的认知

#### 2) 一些小tips

- 善用缓存，避免每帧调用`GameObject.Find()` / `GameObject.FindWithTag()` 等高开销方法

- 命名规范，赋予方法和变量有意义的命名，并统一公有/私有变量的命名标准

- 灵活使用日志，如`Debug.Log()`, `Debug.LogWarning()`来明晰游戏运行中开发者所需的信息或警告，或做功能的`Debug`调试

- 利用`IDE`提供的强大搜索功能来阅读一个模块的代码或调用栈

- 明确“一类一对象”的面向对象程序设计原则，不要设计出一个巨类（如将输入，移动，摄像机，动画，行为逻辑(`Ani`分配等)全部写在一个`Player.cs`脚本中）


