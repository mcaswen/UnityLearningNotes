
### 1. 快照（Snapshot）

- ​**​定义：​**​ 快照是服务器在​**​特定网络时刻（Network Tick）​**​ 捕获的、所有​**​活跃 Ghost 实例​**​的​**​完整状态数据​**​的集合。
    
- ​**​生成：​**​ 服务器按照 `NetworkTickRate`设定的频率（例如每秒 30 次或 60 次）遍历所有活跃的 Ghost。对于每个 Ghost，它会根据其组件上定义的 `[GhostField]`属性，对其需要同步的数据（如位置、旋转、速度等）进行​**​序列化​**​（包括量化、压缩等处理）。所有这些 Ghost 的状态数据打包在一起，就构成了该 Tick 的一个快照。
    
- ​**​目的：​**​ 快照代表了服务器在那一刻的​**​权威游戏状态​**​。它是服务器需要同步给客户端的原始数据源。
    
- ​**​问题：​**​ 如果服务器每次都把完整的快照（包含所有 Ghost 的所有数据）发送给所有客户端，网络带宽会迅速成为瓶颈，尤其是在 Ghost 数量多或状态复杂的情况下。
    

### 2. 基线（Baseline）

- ​**​定义：​**​ 基线本质上就是一个​**​被选作参考点的历史快照​**​。它不是一种特殊类型的快照，而是一个快照被赋予了“基线”的角色。
    
- ​**​作用：​**​ 基线是​**​增量压缩（Delta Compression）​**​ 的基础。服务器不会发送完整的当前快照，而是计算当前快照与一个或多个选定的基线快照之间的​**​差异（Delta）​**​，然后只发送这个差异数据。
    
- ​**​客户端视角：​**​ 对于客户端来说，基线是它​**​已经拥有并确认（Acknowledged）​**​ 的一个快照。客户端在本地存储了这些基线快照的状态。
    
- ​**​重建过程：​**​ 当客户端收到一个 Delta 数据包（相对于某个基线 ID `X`），它会：
    
    1. 从本地缓存中找到基线 ID `X`对应的快照状态。
        
    2. 将收到的 Delta 数据​**​应用（Apply）​**​ 到这个基线状态上。
        
    3. 得到的结果就是服务器发送的​**​新快照​**​的状态。
        
    

### 3. 为什么需要增量压缩（Delta Compression）？

- ​**​核心目标：​**​ ​**​显著减少需要通过网络传输的数据量​**​。
    
- ​**​原理：​**​ 游戏状态通常是​**​连续变化​**​的。相邻几帧之间，大部分 Ghost 的大部分状态（尤其是位置、旋转）的变化量（Delta）相对于它们的绝对值来说通常很小。发送“变化了什么”比发送“所有东西是什么”要高效得多。
    
- ​**​效果：​**​ 对于变化不大的对象，Delta 可能非常小（甚至在某些情况下只需要一个“无变化”的标志位），极大地节省了带宽。
    

### 4. 为什么需要多个基线？（0-3个）

这是增量压缩策略优化的关键。只使用一个基线（通常是客户端确认的最新快照）有时并不是最优的。原因如下：

- ​**​变化累积：​**​ 如果客户端有较高的网络延迟，它确认的最新基线（比如 `Snapshot N`）可能已经落后服务器当前帧（`Snapshot N+M`）很多帧了。在这 `M`帧里，对象的状态可能发生了显著变化。计算 `Snapshot N+M`相对于 `Snapshot N`的 Delta，这个 Delta 可能会很大，压缩效果不好。
    
- ​**​寻找更小的 Delta：​**​ 服务器知道客户端拥有哪些历史快照（通过 ​**​Ack Mask​**​）。它可以在客户端已确认的快照中（不仅仅是最新的那个），​**​选择 1 个、2 个或最多 3 个历史快照作为候选基线​**​。
    
- ​**​计算多个 Delta 并选择最优：​**​ 对于当前要发送的快照 `C`，服务器可能会计算：
    
    - Delta_C_vs_B1 (相对于基线 B1)
        
    - Delta_C_vs_B2 (相对于基线 B2)
        
    - Delta_C_vs_B3 (相对于基线 B3)
        
    - 它还会计算 Delta_C_vs_C-1 (相对于上一帧，如果客户端也有的话)。
        
    
- ​**​选择压缩率最高的：​**​ 服务器会比较计算出的这几个 Delta 的大小（压缩后的字节数）。它会选择​**​生成最小 Delta 数据的那个（或那些）基线​**​进行发送。目标就是找到与当前帧 `C`​**​差异最小​**​的那个历史快照（基线）。
    
- ​**​发送最优 Delta + 基线 ID：​**​ 服务器将选定的最优 Delta 数据，以及它所对应的​**​基线 ID（一个或多个）​**​，一起打包发送给客户端。
    
- ​**​客户端应用：​**​ 客户端根据收到的基线 ID，找到本地存储的对应基线快照，然后将收到的 Delta 应用到该基线上，重建出当前帧 `C`的状态。
    

### 多个基线的优势

1. ​**​更高的压缩率：​**​ 这是最主要的目的。通过从客户端已知的多个历史点中选择差异最小的点作为参考，生成的 Delta 数据量通常比只使用最新基线要小得多。这对于高延迟连接或状态变化剧烈的对象尤其有效。
    
2. ​**​适应网络抖动和丢包：​**​ 如果客户端丢失了某个中间快照，但只要它拥有更早的一个快照（该快照也在服务器的候选基线列表中），服务器仍然可以基于那个更早的基线发送一个有效的（虽然可能稍大一点）Delta，客户端也能正确重建状态，而不需要等待重传丢失的快照（这可能导致卡顿）。
    
3. ​**​灵活性：​**​ 允许服务器根据实际情况（客户端拥有的快照、对象的变化模式）动态选择最优的压缩策略。
    

### 总结

- ​**​快照：​**​ 服务器在特定时刻的完整权威状态数据包。
    
- ​**​基线：​**​ 被选作增量压缩参考点的历史快照（客户端已确认拥有）。
    
- ​**​增量压缩：​**​ 只发送当前状态与基线状态的差异（Delta），而非完整状态，以节省带宽。
    
- ​**​多个基线：​**​ 为了优化增量压缩的效率，服务器会尝试使用客户端已确认的多个（最多 3 个）历史快照作为候选基线，计算当前帧与每个候选基线的差异，并选择生成最小 Delta 数据的基线进行发送。这大大提高了在高延迟或状态变化大时的压缩效率，增强了网络同步的鲁棒性。`Ack Mask`是服务器知道客户端拥有哪些基线（候选快照）的关键依据。