#### 一、`Burst` 是什么
- `Burst` 是一个基于`LLVM`的、为Unity量身定制的高性能编译器。
- 它能够将使用`C#`编写的特定代码（特别是Job System中的代码）编译成**极致优化的本地机器码**，性能可以媲美甚至超越手写的`C++`代码。
- 它的核心价值是用相对安全，易写的`C#`代码，获得接近原生代码的运行性能

#### 二、为什么需要`Burst`?传统`C#`的性能瓶颈
在理解`Burst`之前，我们需要明白标准`C#`（通过`Mono`或`IL2CPP`运行）的一些性能限制：

- **虚函数调用/接口调用**：需要查虚函数表，有间接调用开销
- 垃圾回收压力：频繁的内存分配会触发`GC`，导致卡顿
- **边界检查**：数组访问时，`.NET`会检查索引是否越界，虽然安全但仍有开销
- **优化保守**：`JIT`（即时编译）编译器需要在编译速度和质量之间权衡，无法进行非常激进的全程序优化。

`Burst`的目标就是**消除这些所有开销**

#### 三、`Burst`的工作原理与核心特性
**1. 基于`LLVM`的静态编译**
- **传统`C#`**：代码被编译成**中间语言**（`IL`），在**运行时**由`JIT`编译器（如`Mono`）或`AOT`编译器（如`IL2CPP`）编译成机器码。
- **`Burst`**：在**编辑时或构建时**就直接将`C#`代码编译成高度优化的机器码。它使用和`Clang`/`LLVM`相同的后端技术，这是业界顶级的编译器优化框架。

**2. 针对性的优化策略**
`Burst`知道自己编译的是用于高性能计算的、数据并行的代码，因此它会进行极其激进的优化：
- **内联**：将小函数调用直接**展开**，消除调用开销。这是`Burst`**最常用**也是最有效的优化之一。
- **循环向量化**：性能提升的关键。`Burst`能够将标量循环代码（如对数组每个元素以此计算）自动转换为使用`SIMD`指令的代码。
	- **`SIMD`**：单指令多数据。一条指令可以同时处理4个`float`（`SSE`）或8个`float`（`AVX`）。在这基础上，一个简单的循环速度可以提升4-8倍。
	- **示例**：一个计算c[i] = a[i] + b[i]的循环，`Burst`可以将其编译为一次处理4个或8个数据的`SIMD`指令。
- **消除边界检查**：`Burst`能够分析出某一个循环的索引是否安全，从而移除所有数组访问的边界检查开销。
- **常量传播与死代码消除**：将能确定的值在编译时就计算完毕，并移除永远不会执行到的代码。

**3. 与Unity数学库的深度集成**
`Burst`与`Unity.Mathematics`命名空间下的类型（如`float3`, `quaternion`, `bool4`）是天作之合，

#### 四、如何使用`Burst`?
1. 引用命名空间：`using Unity.Burst;`
2. 添加特性：在`struct`上添加`[BurstCompiler]`特性。
3. 其他使用和原本无异（通常是一个`Job`，实现`IJob`, `IJobParalleFor`等）
**示例：**
```
[BurstCompiler]
public struct MyBurstJob : IJobParallelFor
{
	[ReadOnly] public NativeArray<float> Input;
	[WriteOnly] public NativeArray<float> Output;
	
	public void Execute(int index) 
	{
		//会被优化（向量化）的计算
		Output[index] = math.sqrt(Input[index]) * 2.0f;
	}
}
```

#### 五、`Burst`的优势与带来的性能提升
1. **极致的运行速度**：这是Burst的首要目标。对于数值计算密集型任务，它带来的性能提升通常是2倍 - 10倍，甚至更高，尤其是当循环成功被向量化时。
2. **极低的功耗**：优化后的代码执行效率更高，CPU可以在更短的时间内完成工作然后进入休眠状态，从而降低移动设备的功耗。
3. **无`GC`分配**：Burst编译的代码通常不会产生垃圾，因为它鼓励使用值类型和原生容器，这对于稳定帧率的维持也十分重要。
4. **跨平台一致性**：Burst会为每个目标平台（如`x64`，`ARM64`等）生成特定的最优代码，确保在所有平台上都有高性能表现。

#### 六、Burst的限制与注意事项
1. **支持的`C#`子集**：`Burst`不能编译任意的`C#`代码。它主要支持面向数据的、无托管代码的样式。
	- **支持**：基本类型、结构体、静态方法、大多数控制流。
	- **不支持/限制**：
		- **异常处理**（`try`/`catch`/`finally`）
		- **虚方法调用和接口**（但支持有限的泛型）
		- **字符串操作**（如`ToString`）
		- **委托**（`delegate`）
		- **对托管对象**（如`class`）的访问（只能使用原生容器如`NativeArray`）
		- **反射**
2. 调试难度：由于代码被深度优化和重排，在Burst编译的代码中设置断点和进行源码级调试会更加困难。通常的调试方法是临时禁用Burst（在Job上添加`[BurstCompiler(false)]`）。

#### 七、工作流程
- `ECS`像一个**仓库管理员**，将数据通过缓存友好的方式整齐地摆放在货架上，方便拿取
- `JobSystem`像**施工队长**，接收任务（`Job`）和货架上的数据（`Component`），并分发给工人（CPU核心）高效地，并行地完成。
- `Burst Compiler`像一位**工具大师**，将工人们的**普通工具**（原生C#代码）打磨锋利（高度优化的机器码），从而提高工人的工作效率。
##### **流程**
1. `ECS`以缓存友好的方式储存数据
2. 编写`Job`以定义并行处理这些数据的逻辑和依赖关系
3. 用`[BurstCompiler]`标记这些Job，将其编译为高度优化的机器码
4. 使用`JobSystem`来统一调度和并行执行这些`Burst`优化后的`Job`

#### 总结
- `Burst Compiler`通过提前编译和激进的底层优化，让开发者能够用相对高级的`C#`语言获得底层原生代码的性能。
- 核心理念是通过施加合理的限制（`C#`的安全子集）来换取极致的性能释放。
- 当使用面向数据的思维组织代码时，它是强大的性能加速器。
