### 一、算法概述

- `A*`算法是一种经典的启发式算法，主要用于路径规划和图遍历。

- 在游戏中，主要用于计算玩家行进路径，通过它来计算出避障最短路径

- 它保证了在找到最优解的情况下，通过启发式函数大幅提高搜索效率

- 是 `Dijkstra算法` 的智能优化版本

### 二、核心思想

1. 对游戏场景进行网格状划分，因为`A*`算法是网格地图搜索算法。
	
	- 需要通过网格来对可通行/不可通行区域进行近似，从而使得`A*`算法可以进行基于网格的寻路

2. **评估函数**：$f(n) = g(n) + h(n)$
	
	其中：
	 
	 - g(n)是从起点到节点n的实际代价
	 
	 - h(n)是从节点n到目标点的估计代价
	 
	 - f(n)：节点的总评估代价
 
	 `A*`算法总是优先探索f值最小的节点，即考虑已走过的路径代价，又预估到目标的代价。

	 并在不断寻找邻居最优节点的过程中，找到到终点的最优路径。

3. **数据结构**

	- **开启列表Open Set**
	
		- 待探索的边界节点，用于搜索
		
		- 常用优先队列实现
	
	- **关闭列表Closed Set**
	
		- 已经探索的节点，用于回溯
		
		- 常用哈希集合实现
	
	- **g值表**
	
		- 存储每个节点的实际代价，用于比较
		
		- 常用哈希表实现
	
	- **父节点表**
	
		- 记录节点之间的路径关系，用于回溯
		
		- 常用哈希表实现

### 三、实现思路

![[Pasted image 20251208231040.png]]

- 对于每个邻居节点：

	- 若已经在开启列表中，且比开启列表中存的估价值更小，则对估价值和父节点进行更新。
	
	- 若已经在关闭列表中，且比关闭列表中存的估价值更小，这说明基于关闭列表中已经找到的节点路径是次优的，而新的节点代表的路径可能更优，于是要更新估价值和父节点，并把x从关闭列表中取出，加入开放列表。
	
	- 若都不在，则设置x的父节点，并插入开启列表中，代表该节点等待下一步探索。

- 对邻居节点的遍历结束后，当前节点n节点则视为已探索，加入关闭列表。

	- 这里需要一步排序，确保每次探索都能拿到最小代价节点。若采用优先队列就可以省略排序。

- 终止条件：
	
	- open列表为Null
		
		- 说明所有可能节点都被探索完毕，但仍未找到终点，原因是终点不可达，终止寻路。
	
	- 邻居节点为终点
	
		- 说明最优路径已经找到，通过父节点回溯拿到完整路径并返回。

#### 四、启发函数选择

- **曼哈顿距离**
	
	- 公式：$h = |dx|+ |dy|$，即两点间的水平距离和竖直距离之和
	
	- 适用于4方向移动

- **切比雪夫距离**
	
	- 公式： $h = max(|dx|, |dy|)$，即假设对角线移动代价与水平/数值移动代价相同
	
	- 则距离直接为水平/竖直中更小的那一方的距离移动全部视为对角线移动，加上差值（即在更大的那一方上的直线移动），即为最终距离
	
	- 适用于8方向移动，对角线代价为1

- **Octile距离**

	- 公式：$h = max(dx,dy) + (√2-1)*min(dx,dy)$，是切比雪夫距离的变种，将对角线代价表示为了根号2
	
	- 更符合游戏开发情境，适用于8方向移动

- **欧几里得距离**

	- 公式：$h = √(dx² + dy²)$，允许任意方向移动
	
	- 但适用于连续空间，在网格空间中使用会造成性能浪费

### 五、算法特性

#### 优点：

- `A*`算法是完备的，只要解存在，一定能找到

- 在可采纳启发函数下可以确保找到最优解

- 相比BFS大幅减少了搜索的空间

- 可以根据问题定制启发函数

### 局限性：

- 需要存储所有已探索节点，造成内存消耗

- 启发函数的设计对性能的影响较大

- 不适合高维空间

### 六、优化技巧

1. 开启列表优化

	- 使用优先队列降低增加、删除、获取长度、查找、排序的时间复杂度
	
	- 添加操作：O(logn)
	
	- 删除操作：O(logn)
	
	- 获取长度：O(1)
	
	- 判断是否存在：O(n)
	
	- 排序：O(logn)

2. 使用稳定的排序法，即添加额外条件来使得代价相同但路径不同时，选择路径的策略相同（如更倾向走直线或拐弯）

3. 增加路径的随机性

	- 若固定先向上探索，则每次寻路都会将向上策略设置为优先级最高策略
	
	- 可以加上概率，如四方向下邻居的访问顺序排列有六种可能，则设置每种排列的概率为16%

4. F + H +C启发式优化

	- 将C设置为从当前节点走到该节点的额外代价
	
	- 比如，为了减少拐弯，可以通过判断当前节点到该店是否拐弯去增加F的值
	
	- 但是注意不能加入太多约束，否则`A*`算法可能会产生混乱和冲突

5. 根据实际需求设置二维矩阵的大小
	
	- 定义单个像素符合游戏中物体/人物的比例，从而使得网格数量适中的同时保持算法的有效性
	
6. 分层优化策略 -- HPA
	
	- 将整个地图分为一个个块状的小map，并预计算map之间的通路。
	
	- 这样，在实际寻路时，若路径横跨多个map，可以使用map中预计算好的路径，而非实时计算。



