#### 性能优化的重要性
- **游戏要平衡质量和速度**：
	- 优化的目标不是不计代价地提升帧率，而是在视觉保真度和流畅体验之间找到最佳平衡点。牺牲少量难以察觉的画质细节，换取大幅度提升，通常是值得的。
- **考虑发布平台的特点**：
	- **移动端（IOS/Android）**：受限于发热，电池和硬件性能（GPU/CPU的核心数更少，频率更低，内存带宽更小）。需要更少的多边形数量，更简化的`Shader`，更小的纹理尺寸和分辨率，以及更从简的物理模拟。
	- **PC/主机平台**：硬件强大，但需适应不同配置（从低端到高端的显卡）。可以采用更高质量的特性（如实时阴影，高分辨率后期处理），但仍需对高端图形表现提供开关选项。
- **解决影响性能的瓶颈问题**：
	- **优化必须有的放矢**。盲目优化代码或模型可能收效甚微。首先确定瓶颈在CPU，GPU还是内存，然后针对性地解决

**审查工具**： **`Unity Profiler`**
#### 审查条目
- **CPU使用情况**
	- **常见瓶颈**：
		- **过多的`GameObject`脚本**：`Update()`、 `LateUpdate()`、`FixedUpdate()`中过于频繁的计算或查找操作（如`Find()`，`GetComponent()`）
		- **复杂的物理模拟**：场景中存在过多的碰撞体，刚体，或者复杂的关节
		- **动画**：大量骨骼的动画计算，特别是在使用`Generic`动画类型时
		- **`UI`(`UGUI`)**：`Canvas`元素过多或布局频繁改变导致`Canvas`重建
		- **实例化/销毁（`Instantiate`/`Destroy`）**：运行时频繁创建和销毁对象
	- **优化策略**：
		- **脚本优化**：减少在循环和Update中的操作。使用缓存（缓存组件引用），使用事件代替每帧查询
		- **对象池**：对需要频繁生成/销毁的物体（如子弹/敌人）使用对象池模式，避免内存分配和垃圾回收（`GC`）
		- **物理优化**：简化碰撞体形状（用基本集合体代替`MeshCollider`），减少物理更新频率（`Fixed Timestep`），合理使用碰撞层
		- **动画优化**：在性能敏感平台使用`Humanoid`动画（优化更好），减少活跃的`Animator`数量，使用动画`LOD`（远处禁用动画）
		- `UI`优化：将静态`UI`元素和动态`UI`元素分离到不同的`Canvas`，避免因为一个元素改变导致整个`Canvas`重建。使用`Raycast Target`选项禁用不需要点击事件的`UI`元素
- **渲染（GPU使用情况）**
	- **常见瓶颈**：
		- **`Draw Call`过多**：每个`Draw Call`都需要CPU和GPU之间的通信。物体、材质越多，`Draw Call`越高。
		- **过度绘制**：像素被多次渲染（例如半透明物体重叠、全屏后期效果）
		- **复杂的`Shader`**：计算密集型`Shader`（如那些有复杂光照计算、大量采样、曲面细分等的`Shader`）。
		- **高分辨率纹理**：超出需要的纹理尺寸会占用大量内存带宽
		- **实时阴影**：高分辨率、大范围的实时阴影计算开销巨大
	- **优化策略**：
		- **合批（`Batching`）**:
			- **静态合批（`Static Batching`）**:对不会移动的场景静态物体（如建筑、地形）启用，可大幅降低`Draw Call`，缺点是会增加内存占用。
			- **动态合批（`Dynamic Batching`）**：Unity自动将小型、简单的网格在CPU端合并。对顶点数少的物体有效。
			- **GPU Instancing**：对大量使用相同网格和材质的物体（如草、石头）及其有效
		- **Level of Detail(`LOD`)**：为模型创建多个细节层次的Mesh，根据相机距离切换，降低远处物体的多边形数量。
		- **遮挡剔除（Occlusion Culling）**：避免渲染被其他物体完全遮挡的物体。对室内场景或有很多障碍物的场景非常有效。
		- **纹理优化**：使用纹理压缩（`ASTC for mobile`, `DXT for PC`），制作纹理图集（Atlas），使用`Mipmaps`
		- **简化`Shader`**：为移动平台使用更简单，更高效的`Shader`（如Unity提供的`Mobile`系列）。减少实时灯光数量。
- **内存**
	- **常见问题**：
		- **资源内存**：纹理、网格、音频等资源过大。
		- **托管堆内存**：C#脚本中分配了大量临时对象，引发了频繁的`GC`，导致CPU卡顿。
	- **优化策略**：
		- **资源管理**：在适当时机使用`Resources.UnloadUnusedAssets()`。对大型资源使用异步加载（`Addressables`或`AssetBundle`）
		- **减少`GC`**：避免在Update中分配新对象。重用集合（使用`List.Clear()`而非`new List()`），使用结构体（`Struct`）替代类（`Class`），使用`StringBuilder`处理字符串拼接。
- **音频**
	- **常见问题**：
		- 同时播放过多音频源，使用未压缩`.wav`文件导致内存占用高
	- **优化策略**：
		- 使用音频池管理音效播放，限制同时播放的相同音效数量
- **物理（同CPU）**
	- **优化策略**：
		- 简化碰撞体，调整`Fixed Timestep`，使用合适的碰撞检测模式（`Discrete` vs `Continuous`）

- **全局光照（Global Illumination）**
	- **优化策略**
		- **烘焙光照（Baked GI）**：将静态物体的光照信息预先计算并存于光照贴图（`Lightmap`），运行时几乎无开销
		- **混合光照（Mixed Lighting）**：对静态物体使用烘焙光照，对动态物体使用实时光照。是一种良好的折中方案
		- **简化光照探针（Light Probes）**：用于给动态物体提供间接光照。合理放置，无需过度密集
	
- **用户界面（`UI`）**
	- 优化策略：（在CPU中部分提及）拆分`Canvas`，禁用不必要的`Raycast Target`,避免使用`Camera.main`，使用`Sprite Atlas`

#### Unity中的性能审查流程
1. **建立基线**：运行游戏，使用`Profiler`记录当前的帧率，CPU/GPU时间，内存占用等数据
2. **定位瓶颈**：
	- 打开`Profiler`，观察哪一部分的耗时最长（CPU/GPU）
	- 如果是CPU瓶颈，深入查看CPU `Profiler`，找到最耗时的函数或子系统（如渲染、脚本、动画）
	- 如果是GPU瓶颈，使用`Frame Debugger`逐步查看每个`Draw Call`，或使用`GPU Profiler`深入查看各渲染阶段耗时
	- 使用`Memory Profiler`分析内存使用情况，找出占用最大的资源以及托管内存的来源
3. **实施优化**：根据定位到的问题，应用上述对应的优化策略。 
4. **迭代测试**：每次修改后重新Profiling，对比数据，确认优化是否有效，并检查是否引入了新的问题。
5. **全平台测试**：在所有目标发布平台（低端/高端手机、不同PC配置）上进行性能测试，确保优化策略普遍有效

