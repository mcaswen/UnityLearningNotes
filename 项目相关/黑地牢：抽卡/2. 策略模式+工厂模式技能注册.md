### 一、策略模式

#### 1. 概念

- 策略模式定义了一系列算法，并将每一个算法封装起来，使他们可以相互替换

- 策略模式让算法和逻辑可以独立于使用它的客户端而变化

#### 2. 代码中的体现

- **策略接口/抽象类**：
	
	- **SkillBase**类，一个抽象基类，被所有技能类继承

	- 拥有一个`Execute()`方法，接收`ExecutionContext`类型的技能上下文参数

- **具体策略**：

	- `GenerateShieldSkill`，`LaunchFireBallSkill`等子类，都继承自`SkillBase`
	
	- 并在`Execute()`方法中实现了各自技能的具体行为

- **上下文**：

	- 存储在`SkillSystem`单例中，持有一个工厂模式构建的策略字典集合，根据传入的技能类型在字典中找到技能类示例并执行

#### 3. 策略模式的好处

- 可以很方便地通过新增继承SkillBase的策略类来新增技能，不需要修改现有代码

- 消除了大量条件switch-case语句

### 二、工厂模式

1. **概念**

	- 工厂模式是一种创建型设计模式，提供了一种创建对象的优雅方式
	
	- 在工厂模式下，创建对象时不会对客户端暴露创建模式，并通过使用一个共同的接口来指向新创建的对象

2. **在代码中的体现**

	- **工厂方法**：`InitializeSkillHandlers`方法，创建了所有具体的技能对象，存入`Dictionary<CardDataBase.SkillType, SkillBase> 类型的 skillHandlers`中
	
	- **产品接口**：同样是SkillBase，所有具体技能都会实现这个接口

	- **具体产品**：各种具体的技能类

3. **工厂模式的好处**

	- 将对象的创建和使用分离，使用时，`SkillSystem`不需要知道每个技能对象是如何创建的。
	
	- 集中管理对象的创建，若创建方式改变/需要增加新的对象，只需修改工厂方法

#### 三、两种模式的协同工作

1. **流程示意图**：

![[Pasted image 20251209022523.png]]

2. **模式分离的好处**：

	- 将技能的执行与技能的具体实现解耦；技能的创建与技能的使用解耦
	
	- 当添加新技能时，我们只需要：
	
		- 创建一个新的技能类，实现SkillBase接口
		
		- 在工厂创建方法中注册这个新技能
		
		- 不需要修改`ExecuteSkill()`方法的逻辑，符合开闭原则
	
	- 所有节能的创建和实现都在两个固定方法中，便于管理和维护