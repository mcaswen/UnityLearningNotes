#### 一、概念与边界

“时间轴”在 NetCode for Entities 中不是单一时钟，而是数条以 **`Tick`** 为单位的协同时间线：服务器权威仿真时间轴（`ServerTick` 在服务器端）、客户端的**预测时间轴**（本地 `ServerTick` 在预测循环内推进）、客户端的**插值时间轴**（`InterpolationTick` 与其分数进度），以及与之配套的**命令时间轴**（输入按 Tick 编号）。

这些时间量统一由 `NetworkTime` 暴露，且必须以它为准获取当前仿真刻度与标志位，避免将渲染帧时间当成网络时间使用。`NetworkTime` 用于同时检索“正在模拟/预测的服务器 `Tick`”“插值 `Tick`”以及若干预测标志位。

#### 二、组成要素与语义

**预测侧量：**`ServerTick` 表示当前要模拟/重放的服务器刻度；预测循环内会被设置为“该次正在预测的 Tick”，并辅助以若干布尔标志（如 `IsFirstTimeFullyPredictingTick`，仅在“该 Tick 首次完整预测”时为真，用于约束一次性副作用）。

**插值侧量：**`InterpolationTick` 与 `InterpolationTickFraction` 定义呈现时间轴。分数并非“半个 Tick 的绝对时间点”，而是“朝向目标 Tick 的进度”；例如目标为 11、分数 0.5 的含义是“在 10 与 11 两帧权威快照之间前进到一半”。同理，预测侧也有 `ServerTickFraction`。

**节奏参数：**`ClientServerTickRate` 统一配置**仿真频率**（`SimulationTickRate`）与**快照发送频率**（`NetworkTickRate`）。二者可一致，也可解耦：快照频率可低于仿真频率以节省带宽。

#### 三、三条时间轴如何协同

**1）预测时间轴（交互一致性）**  
在客户端预测循环中，系统按目标 `ServerTick` 逐 `Tick` 推进；每步开始前写入 `NetworkTime.ServerTick`，并据此设置内部步长（含可能的 `partial tick`）。该循环负责在本地重演“服务器会如何演进”，保证输入的即时性。预测阶段，系统会将 `networkTime.ServerTick` 设为“最新被模拟的 Tick”，并区分 partial 与 full。

**2）插值时间轴（视觉稳定性）**  
插值链路不与“当前状态”对接，而是在“两帧已知快照”之间插值，为潜在的抖动与乱序留出缓冲。NetCode 将插值描述为“缓冲快照、延迟若干 Tick，再在两帧已知快照之间插值”，而非“当前→目标”的直接插值；`InterpolationTickFraction` 提供到达目标 Tick 的进度值。

**3）命令时间轴（输入对齐）**  
输入命令以 `Tick` 为键排入缓冲，`NetworkTime` 负责让客户端“略领先”于服务器以便命令到达时机可控，并通过调节本地仿真步长让命令年龄接近目标松弛量（`TargetCommandSlack`）。该设计确保“给定起点状态 + 同一串输入 + 相同步长”可复演到一致结果。

#### 四、为什么要用多时间轴而不是单一时钟

**因果链清晰与可复演性：** 预测用 `ServerTick` 保障“本地逻辑步进与服务器权威刻度一致”；插值单独走 `InterpolationTick(+Fraction)`，保障“视觉在两帧已知快照之间平滑前进”。两条时间轴职能分离，避免将视觉过渡混入权威/预测逻辑，从而维持可回滚与可重放的确定性。该“缓冲快照、在两帧已知点间插值”的策略，正是把呈现与权威演化解耦。

**网络波动可控：** 插值时间轴会引入**预测延迟/插值延迟**，根据 RTT 与抖动自动微调，使画面前进速率平滑且具抗丢包余量；预测时间轴则可在同一帧补跑多个 Tick，以追上目标刻度。

**工程调参自由度：**`SimulationTickRate`、`NetworkTickRate` 分离后，可在 CPU、带宽与可见延迟之间做三角权衡；例如降低快照频率以省带宽，同时维持较高仿真频率以守住操控细腻度。

#### 五、运行细节与边界

**partial tick 的存在与判定：** 当渲染帧长度不足以完整覆盖一个仿真步时，预测会以 `partial tick` 前进；下一次仍会回滚到上一个“完整 `Tick`”再继续，保证每个完整 `Tick` 都可作为稳定的历史锚点。

**分数含义的常见误解：**`InterpolationTickFraction` 与 `ServerTickFraction` 表示“向目标 Tick 前进的进度”，不是“`Tick+0.5` 的绝对采样点”；错误解读会导致相位错误。

**时间源的统一：** 应用层应以 `NetworkTime` 读取时序量，而非 `Time.deltaTime`，否则在回滚/重放与 partial tick 场景中产生不可复现的偏差。

#### 六、节奏配置与可观测指标

**频率配置：** 可通过 `ClientServerTickRate` 配置仿真 Tick 率与快照发送率；默认仿真为 60Hz，可按场景调高或调低。较高仿真频率提升操控细腻度但增加回滚重放成本；较低快照频率节省带宽但提高插值延迟。

**到达进度观测：**`InterpolationTickFraction` 在到达目标 Tick 时为 1.0；无 `partial tick` 的稳态下，分数将保持为 1.0。同理，预测侧 `ServerTickFraction` 在服务器上恒为 1.0，在客户端可变步下处于 (0,1]。

#### 客户端实践

**示例：在展示与预测两条时间轴上取值并分工处理**
```
using Unity.Entities;
using Unity.NetCode;

// 展示层（插值）读取目标 Tick 与分数，驱动视觉平滑
[UpdateInGroup(typeof(PresentationSystemGroup))]
public partial struct InterpVisualSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        var nt = SystemAPI.GetSingleton<NetworkTime>();
        var targetTick  = nt.InterpolationTick;          // 目标插值 Tick
        var progress    = nt.InterpolationTickFraction;  // 向目标的进度 (0,1]
        // 使用 progress 在“上一帧/目标帧快照”之间插值呈现（略）
    }
}

// 预测层按 ServerTick 推进确定性逻辑；一次性副作用只在“首次完整预测”触发
[UpdateInGroup(typeof(PredictedSimulationSystemGroup))]
public partial struct PredictedLogicSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        var nt   = SystemAPI.GetSingleton<NetworkTime>();
        var tick = nt.ServerTick;                        // 当前被预测的 Tick
        var isOnce = nt.IsFirstTimeFullyPredictingTick;  // 首次完整预测门闩
        // 以 tick 对齐地消费命令/推进状态（略）；副作用仅在 isOnce 为真时执行
    }
}

```

#### 小结

时间轴的核心是**多轨并行、各司其职**：预测时间轴用于把交互置于与服务器一致的 `Tick` 语义下重放；插值时间轴用于在两帧权威快照之间平滑过渡；命令时间轴用于确保输入与预测刻度对齐且到达时机可控。

三者统一由 `NetworkTime` 调度与度量，并通过 `ClientServerTickRate` 的两项频率配置在**CPU—带宽—可见延迟**之间完成工程化的平衡。这样组织后的系统具备可回滚、可复演与可调参的时间语义，能够在复杂网络条件下稳定地交付手感与表现。