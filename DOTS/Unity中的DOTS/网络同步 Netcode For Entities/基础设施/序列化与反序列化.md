#### 一、总体机制与作用域

DOTS NetCode for Entities 的序列化/反序列化围绕“**快照（Snapshot）**—以网络 Tick 为键的实体状态镜像”展开：

服务器每 Tick 选择要复制的 Ghost 集，按字段生成**差分数据**并发送；客户端解包后为每个 Ghost 写入**历史缓冲（SnapshotDataBuffer）**，据此进行插值或参与预测/回滚。

此流程以 **GhostField/变体** 决定“哪些字段、以何精度与平滑策略”被纳入快照，以 **重要性/相关性** 控制“哪些 Ghost 被发送”，以 **基线选择 + 增量压缩**控制带宽与 CPU 成本。

快照被限制在 **最大传输单元`MTU`** 内，发送端会生成**部分快照**分批传输，高重要性 `Ghost` 优先进入包体。

#### 二、发送端（服务器）序列化：从“字段”到“比特流”

**1）选择对象与装配快照**  
服务器按 `NetworkTickRate` 组装本 `Tick` 的快照帧。若总字节数逼近 `MTU`，则只打包部分 Ghost；排序是依据重要性的，其能够保证关键对象先被发送，而未发送的对象则在随后的 Tick 继续被序列化。

**2）字段级序列化与量化**  
被标注为 `GhostField` 的字段会进入序列化路径；对于浮点等类型的字段，可设置 `Quantization` 将值放大并转为整数以减少比特数；

插值/外推等属性的 `Smoothing` 与 `MaxSmoothingDistance` 参数仅影响**客户端重建策略**，不改变线上编码格式，常用于位置/朝向的平滑与在“瞬移”场景下取消平滑插值，直接应用数值。

字段也可启用 `Composite` 将小结构视作“整体变化”。需要特别策略时，可用**类型模板/组件变体**替换默认序列化器。

**3）基线与增量压缩（Delta against Baseline）**  
每个字段会以**基线快照**为参照做差分并比特打包。这一基线是在客户端回传的**确认掩码（ack mask）** 与服务器端快照历史之间选择出来的；

同时DOTS支持调大 `ack` 历史窗口并提供 **单基线（`UseSingleBaseline`）** 等优化以降低 CPU 与内存访问和存储开销。

**4）预序列化与吞吐优化**  
对于“高并发、多客户端共享”的 `Ghost`，可开启**预序列化**：把与连接无关的序列化工作先做一遍，随后对每个连接只做小幅连接相关处理，从而节省多连接下的总 CPU。预序列化是**按 Tick 仍然执行**的，适合高频广播对象，不适合稀发对象。

#### 三、接收端（客户端）反序列化：从“比特流”到“快照历史”

**1）解码与历史缓冲**  
客户端按包内的 `Ghost` 流顺序反序列化，利用发送端所选择的基线重建出**当前 `Tick` 值**，并把这一帧的字段值写入该实体的 **`SnapshotDataBuffer`**（典型 1–12 KB/实体，用于插值与回滚复演）。同时将“已收到的服务器 `Tick`”写入 **`NetworkSnapshotAck`**，作为后续基线选择的依据回传给服务器。

**2）与本地时间轴的衔接**  
反序列化后的帧进入两条消费路径：

- **插值链路**读取“上一帧—当前帧”的历史，按 `Smoothing`/`MaxSmoothingDistance` 进行插值或外推；
    
- **预测链路**在应用快照后，如需校正，会从历史缓冲/权威锚点回滚到起点 `Tick` 再重放至目标 `Tick`。  
    二者共享同一批“按 `Tick` 编号”的快照历史。
    

#### 四、与命令/RPC的对比（通道与语义）

**命令流（ICommandData）**：面向“客户端→服务器”的**连载输入**，以 Tick 为键写入命令缓冲并自动打包发送。每个包携带**当前 Tick 的完整命令**与**前若干 Tick 的增量**用于抗丢包；负载过大将导致丢弃，结构应尽量小。命令与快照共享 Tick 语义，但序列化与带宽管理独立。[Unity 文档+1](https://docs.unity3d.com/Packages/com.unity.netcode%401.0/api/Unity.NetCode.ICommandData.html?utm_source=chatgpt.com)

**RPC（`IRpcCommand`）**：走**可靠管线**、保持有序与必达；存在单包大小限制与在途包数量上限，不宜用于高频状态同步或输入流。`RPC` 更适合“低频控制/事件”，而 `Ghost`/命令承担“高频状态/输入”。

#### 五、为何采用“基线 + 增量”的快照

**带宽与抗丢包的均衡**：字段级差分在稳定状态下能够显著降低字节数；基线总是来自“客户端已确认”的帧，所以即便在乱序/丢包场景下，系统仍能选到可用参照，重建成功率更高。部分快照与重要性排序使带宽超限时仍可以选择渐进式序列化和覆盖世界。

**CPU 与缓存友好**：服务端以 `Chunk` 粒度遍历与序列化，客户端以实体粒度重建，符合“服务端多连接、客户端单连接”的各自访问模式。预序列化与单基线等开关功能的提供能够进一步在“吞吐 vs. 延迟”之间给出调和空间。

**工程可塑性**：`GhostField`、类型模板与变体为“字段粒度—类型粒度—预制体粒度”的三层定制点，允许在不修改业务组件的前提下替换序列化策略。

#### 六、易错点与边界

**动态缓冲的变长代价**：当元素个数变化时，默认策略倾向整体重发，差分粒度有限；大量频繁变长的缓冲会抬升字节数。

**快照过大与分片**：当世界状态暴涨或量化不足时，可能会出现“Snapshot too large/Expect client input loss”等警告；这种情况下，我们应采取重要性裁剪、量化/`Composite`、降低 `NetworkTickRate`等策略，或开启单基线优化。

**基线可用性与 ack 窗口**：若客户端长时间未回传 `ack` 或发生反序列化错误，这会导致基线不可用，压缩比骤降。此时可以通过增大 `SnapshotAckMaskCapacity` 来提升“可选基线”的时间跨度。

#### 七、客户端实践

**示例：字段量化与插值策略**

```
using Unity.Entities;
using Unity.Mathematics;
using Unity.NetCode;

public struct GhostTransform : IComponentData
{
    // 位置：毫米级量化，利于差分压缩；插值平滑呈现
    [GhostField(Quantization = 1000, Smoothing = SmoothingAction.Interpolate)]
    public float3 Position;

    // 旋转：角度量化；大跳变切断插值，避免可见拖尾
    [GhostField(Quantization = 512, Smoothing = SmoothingAction.Interpolate, MaxSmoothingDistance = 0.2f)]
    public quaternion Rotation;
}

```
上述属性分别控制带宽（量化/Composite）、观感（插值/阈值）与反序列化重建行为；语义与取值范围见 `GhostFieldAttribute` 与压缩章节。

#### 八、总结

序列化与反序列化机制以 **`Ghost` 快照**为核心，通过 **`GhostField`/变体** 定义字段级别的复制策略，还采取**基线差分、重要性裁剪、部分快照**等优化策略，得以在带宽与吞吐之间取得平衡；

在这一过程中，客户端会把解包结果存入**快照历史缓冲**，供插值与预测/回滚共享。命令流与 RPC 则分别承担“高频 Tick 输入”与“低频可靠事件”的不同职责，与快照在通道与语义上分工明确。

由此形成“可度量、可调参、可复演”的数据管线，支撑大规模多人场景下的稳定表现与交互一致性。