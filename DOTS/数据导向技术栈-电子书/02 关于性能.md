那么我们要问的问题就是：**“我的 CPU 端代码到底为什么慢？”**常见陷阱有：

- **垃圾回收会带来明显的开销与停顿**：GC 作为自动内存管理器，会负责应用内存的分配与释放。它不仅带来 CPU 与内存的额外开销，有时还会让你的代码**全部暂停**好多毫秒。用户可能感知到这些停顿为轻微的卡顿，或更刺耳的“顿挫”。
    
- **编译器生成的机器码不够理想**：不同编译器的优化强度差异很大，且会随目标平台而变化。
    
- **CPU 核心利用不足**：哪怕当下的入门设备都有多核 CPU，很多游戏仍把大多数逻辑**塞在主线程**，因为写多线程代码既难又容易出错。
    
- **数据不“友好缓存”**：从缓存读取数据远快于从主存读取。访问主存可能让 CPU 空等数百个周期；理想做法是让 CPU 尽可能从缓存读写。最简单的方式是**顺序**读写内存，因此最“友好缓存”的存储形式是**紧凑、连续**的数组。反之，如果你的数据在内存中**支离破碎**，访问时通常会触发昂贵的**缓存未命中**。
    
- **代码本身不“友好缓存”**：代码执行时也要从主存被取到指令缓存。一个策略是尽量减少一个函数在**到处被零散调用**的情况，例如与其把某个函数分散在帧内多处调用，不如在**单一循环**里集中调用，使其每帧最多只需载入一次。
    

以上这些“毛病”在 Unity 项目里并不罕见。更具体地说：

- 虽然 C# **允许**你创建**手动分配**的对象（即不参与 GC 的对象），但在 C# 以及大多数 Unity 项目里，**默认范式**仍是使用会被 GC 管理的**类实例**。实务上，Unity 用户长期用**对象池（pooling）**缓解这个问题（严格说这某种程度上违背了“用 GC 语言”的初衷）。对象池的主要好处，是从**预先分配**的池里高效复用对象，避免频繁创建与释放。
    
- 在 **Unity 编辑器**内，C# 通常用 **Mono（JIT）**编译为机器码；做**独立构建**时，一般用 **IL2CPP（AOT，经 C# IL 交叉到 C++）**能获得更好的运行时表现，但也有代价：比如**构建时间更长**，以及**模组（mod）支持**会更麻烦。
    
- 很多 Unity 项目把全部代码都跑在**主线程**，部分原因是**Unity 让这件事很容易**：
    
    - 诸如 `MonoBehaviour.Update()` 之类的**事件函数**都在主线程运行；
        
    - **大多数 Unity API**只能在主线程被安全调用。
        
- 典型 Unity 项目的**数据布局**往往像**一堆四散的对象**，导致缓存利用很差。这同样与 Unity 的易用性有关：一个 **GameObject** 及其**各个组件**是分别分配的，它们经常落在**内存不同位置**。
    
- 典型 Unity 项目的**代码**也往往不“友好缓存”：
    
    - 传统 C# 与 Unity 的许多 API 鼓励**面向对象**风格，倾向于**大量小函数**和**复杂调用链**；与数据导向不同，这对硬件并不友好；
        
    - 每个 `MonoBehaviour` 的事件函数是**逐个调用**的，**未必**按类型分组；例如你有 1000 个 `Monster`，它们会被**一个个**更新，而不是同类一起；
        
    - 这种 OOP 风格也常引向**抽象过度**的方案，低效被编织进各处，最终让低效更难拆解与定位。