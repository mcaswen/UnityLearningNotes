#### 一、概念与边界

- **快照**：服务器在某个网络 Tick 上对一组 Ghost 的“状态切片”。每个快照独立可寻址（以 Tick 为键），构成**离散时间轴**。
    
- **基线**：客户端已经确认收到的旧快照，用作本帧编码时的**参照帧**。通过对“当前值 − 基线值”做字段级差分，可以显著降低字节数；基线同时也可以是 1~3 帧的集合，用于在丢包/乱序下维持较高的可重建性。
    
- **历史缓冲**：客户端会为每个 `Ghost` 维护的按 `Tick` 编号的环形/分段缓冲，保存若干最近快照，用于插值与预测回滚的取样与起点恢复。
    

#### 二、发送端机制：基线如何被“选中”并发挥作用

**目标与约束**：目标是在不可靠通道、可能乱序/丢包的网络上，使“当前帧”以最少比特被编码，同时保证客户端解码成功率。约束来自：客户端回传的**确认掩码**（哪些旧 `Tick` 已收到）、服务器端可访问的历史窗口、包大小（`MTU`）与 CPU 预算。

**选择过程（要点）**：

1. 以客户端的确认掩码为集合，从“客户端已确认”的 Tick 窗口中挑可用基线；
    
2. 对候选基线估计压缩收益（字段变化掩码+差分幅度），按收益/成本选择 1~3 个作为参照；
    
3. 若收益不明显或 CPU 成本超标，退化为**单基线**甚至“无基线的小段全量”策略（极端情况下）；
    
4. 对同一 `Tick` 的多个 `Ghost`，先按**重要性**排队，优先编码关键对象，剩余对象延后到下一包/下一 `Tick`。
    

**为什么有效**：

- 绝大多数游戏状态在相邻 Tick 的变化是“小且稀疏”的；以旧帧为参照做差分比“发绝对值”更省比特。
    
- 使用**客户端已确认**的旧帧当基线，能在乱序/丢包下维持可用参照；多基线进一步提高“至少有一个参照可用”的概率。
    

#### 四、接收端机制：快照如何“回到时间轴”

**解码与落库**：

1. 按包顺序取出每个 `Ghost` 的编码段，用服务端宣告的基线 `Tick` 在本地历史中定位参照；
    
2. 用差分数据重建“当前 `Tick` 值”；
    
3. 将结果写入该 Ghost 的历史缓冲（以 `Tick` 为键），并更新“已确认”的 `Tick` 状态，形成**反馈闭环**（为下一帧的基线选择提供依据）。
    

**历史缓冲的作用**：

- 对**插值**：持有“上一个权威帧”和“当前权威帧”，可按配置进行插值/短时外推，降低可见抖动。
    
- 对**预测/回滚**：当新的权威帧到达时，可把“回滚起点”对齐到最近的权威帧或最近一次完整预测的备份帧，然后**逐 `Tick` 重放**至目标 Tick，保证过程与时间步长一致。
    

#### 五、为什么这套机制支撑预测与回滚（原理层）

**可复演的前提**：在给定同一个“起点状态”和同一段“输入序列”的前提下，确定性的更新函数 `state(t+1)=F(state(t), input(t))` 可复演到唯一结果。  
**快照 + 历史缓冲**提供的要素是：

- “**起点状态**”由最新的权威快照或“上一次完整预测的状态备份”给出；
    
- “**输入序列**”由按 Tick 编号的命令流提供；
    
- “**时间刻度**”由当前重放的 Tick 与对应的固定步长（PSG 写入的 `ServerTick` 与 `TimeData`）保证一致。  
    在此条件下，回滚到起点并逐 Tick 重放，客户端本地的结果与“服务器从同一起点重算”的结果一致或误差受限。**基线并不改变物理或逻辑，只改变线上字节数**；真正使“回滚成立”的是“快照作为锚点 + 时间轴对齐 + 输入对齐”。
    

#### 六、与替代方案的对比与取舍

- **纯全量帧**：带宽线性放大；在丢包/乱序下需要额外可靠机制或冗余，成本更高。
    
- **事件流/RPC 推送字段变化**：缺乏统一的时间锚，状态重建高度依赖到达顺序与时延；对回滚不友好，容易出现“历史不一致”。
    
- **锁步输入转发**：可复演性强，但要求全局确定性与可靠广播；在服务器权威、异步加载与大规模 Ghost 的场景下工程代价高。
    
- **只插值不预测**：实现简单，但本地交互直接暴露 RTT 级延迟，不满足对即时响应的玩法需求。


“基线 + 快照”的方案在**带宽效率、抗丢包、时间轴一致性**三项上取得更平衡的解，且与“重要性裁剪、预序列化、单基线”等开关组合后，能根据项目目标在**CPU ↔ 带宽 ↔ 抖动/延迟**之间做可控移动。

#### 七、参数与可观测性（客户端相关）

- **Ack 窗口深度**：窗口越大，发送端越容易挑到“客户端已确认”的可用基线，压缩比与稳态解码率越高；过小会导致“无可用基线”频繁回退，包体膨胀。
    
- **基线数量**：多基线提高在乱序/丢包下的成功率与压缩比，但抬升编码 CPU；单基线降低编码成本，代价是个别场景下字节数上升。
    
- **历史缓冲深度**：更深的客户端快照历史缓冲提升插值与回滚的韧性，但增加内存与复制成本；缓冲深度与 `NetworkTickRate`、抖动特征相关。
    
- **重要性/相关性策略**：决定带宽不足时哪些对象“先被看见”；影响插值/预测的主观观感，但不改变机制正确性。
    

#### 八、边界与风险点

- **可用基线缺失**：客户端长时间不回 ack 或历史丢失，会迫使发送端退化为低效编码；需要监控 ack 健康度与窗口设置。
    
- **动态缓冲大幅波动**：元素数频繁变化会削弱差分收益；需要在设计与量化上做特别处理。
    
- **大跳变**：位置/朝向突变导致插值拖尾；通过“最大平滑距离”在重建端切断插值，直接采用最新帧。
    
- **单包过大**：对象与字段过多或量化不足导致包超 MTU；依赖“重要性裁剪 + 分批发送”，并回头收紧字段选择与量化。
    

#### 示例/时序（概念级）
```
时间轴（服务器）:  ... ┃  t-2  ┃  t-1  ┃   t   ┃  t+1 ...
                         ↑基线A   ↑基线B   ↑当前帧

发送端：选择 {A,B} 作为基线 → 对各字段做 (t - A,B) 增量压缩 → 打包
接收端：用 {A,B} 中可用的参照重建 t → 写入本地历史缓冲
插值链路：在 (t-1, t) 之间插值/外推
预测链路：如需校正，从锚点（快照或备份）回滚 → 逐 Tick 重放至当前

```
该时序说明：**基线只服务于“线上压缩/本地解码”**；**快照历史**才是插值与预测回滚的“时间轴燃料”。

#### 结论

“基线 + 快照”提供了**参照一致、时间有锚、网络高效**的状态复制框架：发送端用“客户端已确认”的旧帧作为参照，最小化包体并在乱序/丢包下维持可解码性；接收端用快照历史把状态挂回 Tick 时间轴，插值与预测回滚据此各取所需。

预测之所以“能回到正确轨道”，并非因为基线本身，而是因为**权威锚点 + 历史缓冲 + Tick 对齐**三者共同保证了“从同一起点出发、按同一刻度推进、应用同一输入序列”的可复演性；基线的角色是让这条轨道以可承受的带宽和 CPU 成本运转。