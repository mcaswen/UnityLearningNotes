# 引言（Introduction）

本指南解释 Unity **数据导向技术栈**（DOTS）的潜在性能收益。它提供该技术栈中各个包与特性的高层概览，并讲解若干与**数据导向设计**（DOD）相关、或受其影响的核心概念。本文不深入 API 细节；你会在各处看到大量全新的 DOTS 教程与学习资源链接，便于继续深入。
  
我们的目标，是帮助你判断：你的 Unity 项目是否值得使用 DOTS 的部分或全部特性。

**作者与专家贡献者**  
本电子书由 Unity DOTS 工程师与外部专家合作完成。主笔为 Unity 高级软件工程师 **Brian Will**。其他贡献者包括：**Nik Lever**（实时 3D 与 Unity 教学者）、**Steve McGreal**（软件工程师）、**Daniel Kierkegaard Andersen**（Unity 软件工程师）、**Laurent Gibert**（Unity 产品管理总监）。

# 关于性能（About performance）

如果你是有经验的游戏开发者，你会知道：**目标平台上的性能优化**贯穿整个开发周期。也许你的游戏在高端 PC 上表现良好，但你同时瞄准的低端移动平台呢？是否存在**某些帧远慢于其他帧**，造成明显卡顿？加载时间是否恼人，玩家每次穿门都会**卡住整整几秒**？在这种情况下，不只是体验不佳，你也被**有效阻止**继续加内容：更细致与更大规模的环境、机制、角色与行为、物理，以及更多平台。

**罪魁祸首是什么？**许多项目是渲染出了问题：贴图过大、网格过于复杂、着色器开销高，或者**批处理、裁剪、LOD** 的使用低效。
  
另一个常见陷阱是**过度使用复杂网格碰撞体**，这会显著拉高物理模拟成本。或者，**游戏模拟本身**很慢——你为游戏“灵魂”所写的 C# 代码，每帧吃掉了过多的 CPU 毫秒数。

**那要如何写出快的（至少不慢的）游戏代码？**


在过去几十年里，PC 游戏开发者常常靠“**等一等**”来解决：从 20 世纪 70 年代到 21 世纪，**CPU 单线程性能**基本**每隔数年翻倍**（即“摩尔定律”），因此一款 PC 游戏在生命周期里会“**神奇地**”变快。过去二十年里，单线程性能增幅**相对温和**；取而代之的是**CPU 核心数**的增长——即便小型的智能手机也有多个核心。同时，高端与低端设备的**性能鸿沟扩大**，大量玩家的硬件已经**相当老旧**。**坐等硬件变快**已不再是可行策略。